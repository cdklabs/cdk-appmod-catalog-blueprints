// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import { PythonFunction } from '@aws-cdk/aws-lambda-python-alpha';
import { PropertyInjectors, RemovalPolicy, Stack } from 'aws-cdk-lib';
import { PolicyDocument, PolicyStatement, Role, ServicePrincipal } from 'aws-cdk-lib/aws-iam';
import { Key } from 'aws-cdk-lib/aws-kms';
import { Architecture, ILayerVersion, LayerVersion } from 'aws-cdk-lib/aws-lambda';
import { Asset } from 'aws-cdk-lib/aws-s3-assets';
import { Construct } from 'constructs';
import { LambdaIamUtils, LambdaObservabilityPropertyInjector, LogGroupDataProtectionProps, LogGroupDataProtectionUtils, ObservableProps } from '../../utilities';
import { BedrockModelProps, BedrockModelUtils } from '../bedrock';
import { Network } from '../foundation';
import { InvokeType } from './invoke-type';
import { IKnowledgeBase, KnowledgeBaseRuntimeConfig } from './knowledge-base';

// Re-export InvokeType for convenience
export { InvokeType };

export interface AgentToolsLocationDefinition {
  readonly bucketName: string;
  readonly key: string;
  readonly isFile: boolean;
  readonly isZipArchive: boolean;
}

/**
 * Parameters that influences the behavior of the agent
 */
export interface AgentDefinitionProps {
  /**
     * Configuration for the Bedrock Model to be used
     */
  readonly bedrockModel: BedrockModelProps;

  /**
     * The system prompt of the agent
     *
     */
  readonly systemPrompt: Asset;

  /**
     * List of tools defined in python files. This tools would automatically
     * be loaded by the agent. You can also use this to incorporate other specialized
     * agents as tools.
     */
  readonly tools?: Asset[];

  /**
     * Any dependencies needed by the provided tools
     */
  readonly lambdaLayers?: LayerVersion[];

  /**
     * If tools need additional IAM permissions, these statements
     * would be attached to the Agent's IAM role
     */
  readonly additionalPolicyStatementsForTools?: PolicyStatement[];

  /**
   * Knowledge bases available to the agent for Retrieval-Augmented Generation (RAG).
   *
   * When configured, the agent will have access to a built-in retrieval tool
   * that can query these knowledge bases. The agent's system prompt will be
   * automatically augmented with information about available knowledge bases.
   *
   * Each knowledge base must implement the IKnowledgeBase interface, which
   * handles IAM permission generation and runtime configuration.
   *
   * @default - No knowledge bases configured
   */
  readonly knowledgeBases?: IKnowledgeBase[];

  /**
   * Additional IAM policy statements for knowledge base access.
   *
   * Use this when knowledge bases require permissions beyond what is
   * automatically generated by the IKnowledgeBase implementations.
   * These statements will be added to the agent's IAM role in addition
   * to the auto-generated permissions.
   *
   * @default - Only auto-generated permissions from knowledge bases
   */
  readonly additionalPolicyStatementsForKnowledgeBases?: PolicyStatement[];
}

export interface BaseAgentProps extends ObservableProps {

  /**
     * Name of the agent
     */
  readonly agentName: string;

  /**
     * Agent related parameters
     */
  readonly agentDefinition: AgentDefinitionProps;

  /**
   * Enable observability for the agent
   *
   * When enabled, configures both Lambda Powertools and AWS Bedrock AgentCore observability:
   * - **Lambda Powertools**: Provides function-level observability including structured logging,
   *   distributed tracing with X-Ray, and custom metrics
   * - **AgentCore Observability**: Provides agent-specific observability including agent invocations,
   *   reasoning steps, tool usage, token consumption, and agent latency
   *
   * Both systems publish to Amazon CloudWatch and use the same service name and namespace
   * for correlation. This provides complete visibility at both function and agent levels.
   *
   * **Environment Variables Set** (AgentCore):
   * - `AGENT_OBSERVABILITY_ENABLED`: Enables AgentCore observability
   * - `OTEL_RESOURCE_ATTRIBUTES`: Service identification for OpenTelemetry
   * - `OTEL_EXPORTER_OTLP_LOGS_HEADERS`: Agent identification headers
   * - `AWS_LAMBDA_EXEC_WRAPPER`: ADOT wrapper for automatic instrumentation
   *
   * **IAM Permissions Granted** (AgentCore):
   * - CloudWatch Logs: `logs:CreateLogGroup`, `logs:CreateLogStream`, `logs:PutLogEvents`
   * - X-Ray: `xray:PutTraceSegments`, `xray:PutTelemetryRecords`
   *
   * **Additional Requirements**:
   * - BatchAgent automatically adds ADOT (AWS Distro for OpenTelemetry) Lambda Layer
   *
   * @see https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/observability-configure.html
   * @default false
   */
  readonly enableObservability?: boolean;

  /**
     * If the Agent would be running inside a VPC
     *
     * @default Agent would not be in a VPC
     */
  readonly network?: Network;

  /**
     * Encryption key to encrypt agent environment variables
     *
     * @default new KMS Key would be created
     */
  readonly encryptionKey?: Key;

  /**
     * Removal policy for resources created by this
     * construct
     *
     * @default RemovalPolicy.DESTROY
     */
  readonly removalPolicy?: RemovalPolicy;

  /**
   * The architecture used by the Lambda function where the
   * agent is hosted
   *
   * @default Architecture.ARM_64
   */
  readonly agentArchitecture?: Architecture;
}

/**
 * Base class for all agent types in the framework
 *
 * Provides common infrastructure for AI agents including:
 * - IAM role and permissions management
 * - Encryption key for environment variables
 * - Tool integration and S3 asset management
 * - Knowledge base integration for RAG (Retrieval-Augmented Generation)
 * - Observability configuration (Lambda Powertools + AgentCore)
 *
 * Subclasses must implement the agent-specific Lambda function creation.
 *
 * **Observability**: When `enableObservability: true`, BaseAgent configures both
 * Lambda Powertools (function-level) and AWS Bedrock AgentCore (agent-level)
 * observability. Both systems work together to provide complete visibility:
 * - Lambda Powertools captures function execution, logs, and custom metrics
 * - AgentCore captures agent reasoning, tool usage, and token consumption
 * - Both publish to CloudWatch with correlated service names for unified monitoring
 *
 * The observability integration includes:
 * - Automatic IAM permission grants for CloudWatch Logs and X-Ray
 * - Environment variable configuration for OpenTelemetry
 * - ADOT Lambda Layer attachment (handled by concrete implementations)
 *
 * @see https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/observability-configure.html
 */
export abstract class BaseAgent extends Construct {
  public abstract readonly agentFunction: PythonFunction;
  public readonly bedrockModel?: BedrockModelProps;
  public readonly agentRole: Role;
  public readonly encryptionKey: Key;
  /** log group data protection configuration */
  protected readonly logGroupDataProtection: LogGroupDataProtectionProps;
  protected readonly agentToolsLocationDefinitions: AgentToolsLocationDefinition[];
  /**
   * Knowledge base configurations for runtime use.
   *
   * This array contains the exported configurations from all configured
   * knowledge bases. Subclasses use this to set the KNOWLEDGE_BASES_CONFIG
   * environment variable on the agent Lambda function.
   */
  protected readonly knowledgeBaseConfigs: KnowledgeBaseRuntimeConfig[];
  /**
   * Asset containing the knowledge base retrieval tool.
   *
   * This is automatically created when knowledge bases are configured.
   * The asset is added to the agent's tools and granted read access.
   */
  protected readonly knowledgeBaseToolAsset?: Asset;
  /**
   * Lambda layers required by knowledge base retrieval tools.
   *
   * This array contains Lambda layers from all configured knowledge bases.
   * Subclasses should add these layers to the agent Lambda function to
   * ensure retrieval tools have access to required dependencies.
   */
  protected readonly knowledgeBaseLayers: LayerVersion[];

  constructor(scope: Construct, id: string, props: BaseAgentProps) {
    super(scope, id);
    this.bedrockModel = props.agentDefinition.bedrockModel;
    this.encryptionKey = props.encryptionKey || new Key(this, 'AgentEncryptionKey', {
      enableKeyRotation: true,
      removalPolicy: props.removalPolicy || RemovalPolicy.DESTROY,
    });


    const inlinePolicies: Record<string, PolicyDocument> = {};

    if (props.agentDefinition.additionalPolicyStatementsForTools && props.agentDefinition.additionalPolicyStatementsForTools.length > 0) {
      inlinePolicies.ToolPermissions = new PolicyDocument({
        statements: props.agentDefinition.additionalPolicyStatementsForTools,
      });
    }

    // Generate IAM permissions from knowledge bases
    const knowledgeBases = props.agentDefinition.knowledgeBases ?? [];
    const kbPolicyStatements: PolicyStatement[] = [];

    for (const kb of knowledgeBases) {
      const permissions = kb.generateIamPermissions();
      kbPolicyStatements.push(...permissions);
    }

    // Add additional KB policy statements if provided
    if (props.agentDefinition.additionalPolicyStatementsForKnowledgeBases) {
      kbPolicyStatements.push(...props.agentDefinition.additionalPolicyStatementsForKnowledgeBases);
    }

    // Add KB permissions as inline policy if any exist
    if (kbPolicyStatements.length > 0) {
      inlinePolicies.KnowledgeBasePermissions = new PolicyDocument({
        statements: kbPolicyStatements,
      });
    }

    this.agentRole = new Role(this, `Agent-${props.agentName}-Role`, {
      assumedBy: new ServicePrincipal('lambda.amazonaws.com'),
      inlinePolicies,
    });

    if (props.network) {
      this.agentRole.addToPrincipalPolicy(LambdaIamUtils.generateLambdaVPCPermissions());
    }

    this.agentToolsLocationDefinitions = [];

    if (props.agentDefinition.tools) {
      for (const tool of props.agentDefinition.tools) {
        tool.grantRead(this.agentRole);

        this.agentToolsLocationDefinitions.push({
          bucketName: tool.s3BucketName,
          key: tool.s3ObjectKey,
          isFile: tool.isFile,
          isZipArchive: tool.isZipArchive,
        });
      }
    }

    // Store knowledge base configurations for subclass access
    this.knowledgeBaseConfigs = knowledgeBases.map(kb => kb.exportConfiguration());

    // Initialize knowledge base layers array
    this.knowledgeBaseLayers = [];

    // Get retrieval tool assets from knowledge bases
    // Each KB type provides its own retrieval tool implementation
    if (knowledgeBases.length > 0) {
      // Collect unique retrieval tool assets from knowledge bases
      // Use a Map to deduplicate by asset path (same KB type = same tool)
      const toolAssetMap = new Map<string, Asset>();

      for (const kb of knowledgeBases) {
        // Check if the KB provides a retrieval tool
        if (kb.retrievalToolAsset) {
          const toolAsset = kb.retrievalToolAsset();
          if (toolAsset) {
            // Use the S3 object key as a unique identifier for deduplication
            const key = toolAsset.s3ObjectKey;
            if (!toolAssetMap.has(key)) {
              toolAssetMap.set(key, toolAsset);
            }
          }
        }

        // Collect Lambda layers from knowledge bases
        if (kb.retrievalToolLayers) {
          const layers = kb.retrievalToolLayers();
          if (layers && layers.length > 0) {
            this.knowledgeBaseLayers.push(...layers);
          }
        }
      }

      // Add each unique retrieval tool to the agent
      for (const asset of toolAssetMap.values()) {
        // Store the first tool asset for backward compatibility
        if (!this.knowledgeBaseToolAsset) {
          this.knowledgeBaseToolAsset = asset;
        }

        // Grant read access to the retrieval tool asset
        asset.grantRead(this.agentRole);

        // Add retrieval tool to agent tools location definitions
        this.agentToolsLocationDefinitions.push({
          bucketName: asset.s3BucketName,
          key: asset.s3ObjectKey,
          isFile: asset.isFile,
          isZipArchive: asset.isZipArchive,
        });
      }
    }

    this.agentRole.addToPrincipalPolicy(BedrockModelUtils.generateModelIAMPermissions(this, this.bedrockModel));
    this.logGroupDataProtection = LogGroupDataProtectionUtils.handleDefault(this, props.logGroupDataProtection, props.removalPolicy);

    if (props.enableObservability) {
      PropertyInjectors.of(this).add(
        new LambdaObservabilityPropertyInjector(this.logGroupDataProtection),
      );

      // Add IAM permissions for AgentCore observability
      this.agentRole.addToPrincipalPolicy(new PolicyStatement({
        actions: [
          'logs:CreateLogGroup',
          'logs:CreateLogStream',
          'logs:PutLogEvents',
          'xray:PutTraceSegments',
          'xray:PutTelemetryRecords',
        ],
        resources: ['*'], // CloudWatch Logs and X-Ray require wildcard resources
      }));
    }
  }

  /**
   * Creates the AWS Distro for OpenTelemetry (ADOT) Lambda Layer.
   *
   * The ADOT layer provides automatic instrumentation for observability.
   * Layer versions vary by region - some regions have newer versions with
   * better Python 3.13 support. If you encounter compatibility issues,
   * the layer ARNs can be found at:
   * https://aws-otel.github.io/docs/getting-started/lambda#adot-lambda-layer-arns
   *
   * @returns The ADOT Lambda Layer for the current region
   * @throws Error if the region is not supported
   */
  protected createADOTLayer(): ILayerVersion {
    const { region } = Stack.of(this);

    // AWS Distro for OpenTelemetry (ADOT) Lambda Layer ARNs by region
    // Source: https://aws-otel.github.io/docs/getting-started/lambda#adot-lambda-layer-arns
    const adotLayerArnMap: Record<string, string> = {
      'af-south-1': 'arn:aws:lambda:af-south-1:904233096616:layer:AWSOpenTelemetryDistroPython:17',
      'ap-east-1': 'arn:aws:lambda:ap-east-1:888577020596:layer:AWSOpenTelemetryDistroPython:17',
      'ap-northeast-1': 'arn:aws:lambda:ap-northeast-1:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'ap-northeast-2': 'arn:aws:lambda:ap-northeast-2:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'ap-northeast-3': 'arn:aws:lambda:ap-northeast-3:615299751070:layer:AWSOpenTelemetryDistroPython:19',
      'ap-south-1': 'arn:aws:lambda:ap-south-1:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'ap-south-2': 'arn:aws:lambda:ap-south-2:796973505492:layer:AWSOpenTelemetryDistroPython:17',
      'ap-southeast-1': 'arn:aws:lambda:ap-southeast-1:615299751070:layer:AWSOpenTelemetryDistroPython:19',
      'ap-southeast-2': 'arn:aws:lambda:ap-southeast-2:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'ap-southeast-3': 'arn:aws:lambda:ap-southeast-3:039612877180:layer:AWSOpenTelemetryDistroPython:17',
      'ap-southeast-4': 'arn:aws:lambda:ap-southeast-4:713881805771:layer:AWSOpenTelemetryDistroPython:17',
      'ap-southeast-5': 'arn:aws:lambda:ap-southeast-5:152034782359:layer:AWSOpenTelemetryDistroPython:8',
      'ap-southeast-7': 'arn:aws:lambda:ap-southeast-7:980416031188:layer:AWSOpenTelemetryDistroPython:8',
      'ca-central-1': 'arn:aws:lambda:ca-central-1:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'ca-west-1': 'arn:aws:lambda:ca-west-1:595944127152:layer:AWSOpenTelemetryDistroPython:8',
      'cn-north-1': 'arn:aws-cn:lambda:cn-north-1:440179912924:layer:AWSOpenTelemetryDistroPython:8',
      'cn-northwest-1': 'arn:aws-cn:lambda:cn-northwest-1:440180067931:layer:AWSOpenTelemetryDistroPython:8',
      'eu-central-1': 'arn:aws:lambda:eu-central-1:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'eu-central-2': 'arn:aws:lambda:eu-central-2:156041407956:layer:AWSOpenTelemetryDistroPython:17',
      'eu-north-1': 'arn:aws:lambda:eu-north-1:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'eu-south-1': 'arn:aws:lambda:eu-south-1:257394471194:layer:AWSOpenTelemetryDistroPython:17',
      'eu-south-2': 'arn:aws:lambda:eu-south-2:490004653786:layer:AWSOpenTelemetryDistroPython:17',
      'eu-west-1': 'arn:aws:lambda:eu-west-1:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'eu-west-2': 'arn:aws:lambda:eu-west-2:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'eu-west-3': 'arn:aws:lambda:eu-west-3:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'il-central-1': 'arn:aws:lambda:il-central-1:746669239226:layer:AWSOpenTelemetryDistroPython:17',
      'me-central-1': 'arn:aws:lambda:me-central-1:739275441131:layer:AWSOpenTelemetryDistroPython:17',
      'me-south-1': 'arn:aws:lambda:me-south-1:980921751758:layer:AWSOpenTelemetryDistroPython:17',
      'mx-central-1': 'arn:aws:lambda:mx-central-1:610118373846:layer:AWSOpenTelemetryDistroPython:8',
      'sa-east-1': 'arn:aws:lambda:sa-east-1:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'us-east-1': 'arn:aws:lambda:us-east-1:615299751070:layer:AWSOpenTelemetryDistroPython:23',
      'us-east-2': 'arn:aws:lambda:us-east-2:615299751070:layer:AWSOpenTelemetryDistroPython:20',
      'us-west-1': 'arn:aws:lambda:us-west-1:615299751070:layer:AWSOpenTelemetryDistroPython:27',
      'us-west-2': 'arn:aws:lambda:us-west-2:615299751070:layer:AWSOpenTelemetryDistroPython:27',
    };

    const adotLayerArn = adotLayerArnMap[region];

    if (!adotLayerArn) {
      throw new Error(
        `ADOT Lambda Layer not available in region ${region}. ` +
        `Supported regions: ${Object.keys(adotLayerArnMap).join(', ')}`,
      );
    }

    return LayerVersion.fromLayerVersionArn(this, 'AdotLayer', adotLayerArn);
  }
}