// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import { PythonFunction } from '@aws-cdk/aws-lambda-python-alpha';
import { PropertyInjectors, RemovalPolicy } from 'aws-cdk-lib';
import { PolicyDocument, PolicyStatement, Role, ServicePrincipal } from 'aws-cdk-lib/aws-iam';
import { Key } from 'aws-cdk-lib/aws-kms';
import { LayerVersion } from 'aws-cdk-lib/aws-lambda';
import { Asset } from 'aws-cdk-lib/aws-s3-assets';
import { Construct } from 'constructs';
import { LambdaIamUtils, LambdaObservabilityPropertyInjector, LogGroupDataProtectionProps, LogGroupDataProtectionUtils, ObservableProps } from '../../utilities';
import { BedrockModelProps, BedrockModelUtils } from '../bedrock';
import { Network } from '../foundation';
import { InvokeType } from './invoke-type';
import { IKnowledgeBase, KnowledgeBaseRuntimeConfig } from './knowledge-base';

// Re-export InvokeType for convenience
export { InvokeType };

export interface AgentToolsLocationDefinition {
  readonly bucketName: string;
  readonly key: string;
  readonly isFile: boolean;
  readonly isZipArchive: boolean;
}

/**
 * Parameters that influences the behavior of the agent
 */
export interface AgentDefinitionProps {
  /**
     * Configuration for the Bedrock Model to be used
     */
  readonly bedrockModel: BedrockModelProps;

  /**
     * The system prompt of the agent
     *
     */
  readonly systemPrompt: Asset;

  /**
     * List of tools defined in python files. This tools would automatically
     * be loaded by the agent. You can also use this to incorporate other specialized
     * agents as tools.
     */
  readonly tools?: Asset[];

  /**
     * Any dependencies needed by the provided tools
     */
  readonly lambdaLayers?: LayerVersion[];

  /**
     * If tools need additional IAM permissions, these statements
     * would be attached to the Agent's IAM role
     */
  readonly additionalPolicyStatementsForTools?: PolicyStatement[];

  /**
   * Knowledge bases available to the agent for Retrieval-Augmented Generation (RAG).
   *
   * When configured, the agent will have access to a built-in retrieval tool
   * that can query these knowledge bases. The agent's system prompt will be
   * automatically augmented with information about available knowledge bases.
   *
   * Each knowledge base must implement the IKnowledgeBase interface, which
   * handles IAM permission generation and runtime configuration.
   *
   * @default - No knowledge bases configured
   */
  readonly knowledgeBases?: IKnowledgeBase[];

  /**
   * Additional IAM policy statements for knowledge base access.
   *
   * Use this when knowledge bases require permissions beyond what is
   * automatically generated by the IKnowledgeBase implementations.
   * These statements will be added to the agent's IAM role in addition
   * to the auto-generated permissions.
   *
   * @default - Only auto-generated permissions from knowledge bases
   */
  readonly additionalPolicyStatementsForKnowledgeBases?: PolicyStatement[];
}

export interface BaseAgentProps extends ObservableProps {

  /**
     * Name of the agent
     */
  readonly agentName: string;

  /**
     * Agent related parameters
     */
  readonly agentDefinition: AgentDefinitionProps;

  /**
     * Enable observability
     *
     * @default false
     */
  readonly enableObservability?: boolean;

  /**
     * If the Agent would be running inside a VPC
     *
     * @default Agent would not be in a VPC
     */
  readonly network?: Network;

  /**
     * Encryption key to encrypt agent environment variables
     *
     * @default new KMS Key would be created
     */
  readonly encryptionKey?: Key;

  /**
     * Removal policy for resources created by this
     * construct
     *
     * @default RemovalPolicy.DESTROY
     */
  readonly removalPolicy?: RemovalPolicy;
}

export abstract class BaseAgent extends Construct {
  public abstract readonly agentFunction: PythonFunction;
  public readonly bedrockModel?: BedrockModelProps;
  public readonly agentRole: Role;
  public readonly encryptionKey: Key;
  /** log group data protection configuration */
  protected readonly logGroupDataProtection: LogGroupDataProtectionProps;
  protected readonly agentToolsLocationDefinitions: AgentToolsLocationDefinition[];
  /**
   * Knowledge base configurations for runtime use.
   *
   * This array contains the exported configurations from all configured
   * knowledge bases. Subclasses use this to set the KNOWLEDGE_BASES_CONFIG
   * environment variable on the agent Lambda function.
   */
  protected readonly knowledgeBaseConfigs: KnowledgeBaseRuntimeConfig[];
  /**
   * Asset containing the knowledge base retrieval tool.
   *
   * This is automatically created when knowledge bases are configured.
   * The asset is added to the agent's tools and granted read access.
   */
  protected readonly knowledgeBaseToolAsset?: Asset;
  /**
   * Lambda layers required by knowledge base retrieval tools.
   *
   * This array contains Lambda layers from all configured knowledge bases.
   * Subclasses should add these layers to the agent Lambda function to
   * ensure retrieval tools have access to required dependencies.
   */
  protected readonly knowledgeBaseLayers: LayerVersion[];

  constructor(scope: Construct, id: string, props: BaseAgentProps) {
    super(scope, id);
    this.bedrockModel = props.agentDefinition.bedrockModel;
    this.encryptionKey = props.encryptionKey || new Key(this, 'AgentEncryptionKey', {
      enableKeyRotation: true,
      removalPolicy: props.removalPolicy || RemovalPolicy.DESTROY,
    });


    const inlinePolicies: Record<string, PolicyDocument> = {};

    if (props.agentDefinition.additionalPolicyStatementsForTools && props.agentDefinition.additionalPolicyStatementsForTools.length > 0) {
      inlinePolicies.ToolPermissions = new PolicyDocument({
        statements: props.agentDefinition.additionalPolicyStatementsForTools,
      });
    }

    // Generate IAM permissions from knowledge bases
    const knowledgeBases = props.agentDefinition.knowledgeBases ?? [];
    const kbPolicyStatements: PolicyStatement[] = [];

    for (const kb of knowledgeBases) {
      const permissions = kb.generateIamPermissions();
      kbPolicyStatements.push(...permissions);
    }

    // Add additional KB policy statements if provided
    if (props.agentDefinition.additionalPolicyStatementsForKnowledgeBases) {
      kbPolicyStatements.push(...props.agentDefinition.additionalPolicyStatementsForKnowledgeBases);
    }

    // Add KB permissions as inline policy if any exist
    if (kbPolicyStatements.length > 0) {
      inlinePolicies.KnowledgeBasePermissions = new PolicyDocument({
        statements: kbPolicyStatements,
      });
    }

    this.agentRole = new Role(this, `Agent-${props.agentName}-Role`, {
      assumedBy: new ServicePrincipal('lambda.amazonaws.com'),
      inlinePolicies,
    });

    if (props.network) {
      this.agentRole.addToPrincipalPolicy(LambdaIamUtils.generateLambdaVPCPermissions());
    }

    this.agentToolsLocationDefinitions = [];

    if (props.agentDefinition.tools) {
      for (const tool of props.agentDefinition.tools) {
        tool.grantRead(this.agentRole);

        this.agentToolsLocationDefinitions.push({
          bucketName: tool.s3BucketName,
          key: tool.s3ObjectKey,
          isFile: tool.isFile,
          isZipArchive: tool.isZipArchive,
        });
      }
    }

    // Store knowledge base configurations for subclass access
    this.knowledgeBaseConfigs = knowledgeBases.map(kb => kb.exportConfiguration());

    // Initialize knowledge base layers array
    this.knowledgeBaseLayers = [];

    // Get retrieval tool assets from knowledge bases
    // Each KB type provides its own retrieval tool implementation
    if (knowledgeBases.length > 0) {
      // Collect unique retrieval tool assets from knowledge bases
      // Use a Map to deduplicate by asset path (same KB type = same tool)
      const toolAssetMap = new Map<string, Asset>();

      for (const kb of knowledgeBases) {
        // Check if the KB provides a retrieval tool
        if (kb.retrievalToolAsset) {
          const toolAsset = kb.retrievalToolAsset();
          if (toolAsset) {
            // Use the S3 object key as a unique identifier for deduplication
            const key = toolAsset.s3ObjectKey;
            if (!toolAssetMap.has(key)) {
              toolAssetMap.set(key, toolAsset);
            }
          }
        }

        // Collect Lambda layers from knowledge bases
        if (kb.retrievalToolLayers) {
          const layers = kb.retrievalToolLayers();
          if (layers && layers.length > 0) {
            this.knowledgeBaseLayers.push(...layers);
          }
        }
      }

      // Add each unique retrieval tool to the agent
      for (const asset of toolAssetMap.values()) {
        // Store the first tool asset for backward compatibility
        if (!this.knowledgeBaseToolAsset) {
          this.knowledgeBaseToolAsset = asset;
        }

        // Grant read access to the retrieval tool asset
        asset.grantRead(this.agentRole);

        // Add retrieval tool to agent tools location definitions
        this.agentToolsLocationDefinitions.push({
          bucketName: asset.s3BucketName,
          key: asset.s3ObjectKey,
          isFile: asset.isFile,
          isZipArchive: asset.isZipArchive,
        });
      }
    }

    this.agentRole.addToPrincipalPolicy(BedrockModelUtils.generateModelIAMPermissions(this, this.bedrockModel));
    this.logGroupDataProtection = LogGroupDataProtectionUtils.handleDefault(this, props.logGroupDataProtection, props.removalPolicy);

    if (props.enableObservability) {
      PropertyInjectors.of(this).add(
        new LambdaObservabilityPropertyInjector(this.logGroupDataProtection),
      );
    }
  }
}